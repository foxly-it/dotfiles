#!/bin/bash
#
# - Nur IPs physischer NICs (keine Docker/veth/lo)
# - Remote-IP ermitteln
# - Ab 1 Woche: Uptime ohne Stunden/Minuten

# ---- Optik ----
COLOR="\033[38;5;114m"
RESET="\033[0m"
GAP=3
LOLCAT_BIN="/usr/local/bin/lolcat"
LOLCAT_ARGS="-f -p 1.2 -F 0.3"

# ---- Optionen ----
UPGRADE_MODE="upgrade"
if [ "${1:-}" = "--dist" ]; then
  UPGRADE_MODE="dist-upgrade"
fi

# ---- Helfer: deutsche Uptime ----
de_uptime() {
  local s="$1" w d h m res=""
  w=$(( s/604800 )); s=$(( s%604800 ))
  d=$(( s/86400  )); s=$(( s%86400  ))
  h=$(( s/3600   )); s=$(( s%3600   ))
  m=$(( s/60     ))

  if [ "$w" -gt 0 ]; then
    [ "$w" -eq 1 ] && res="1 Woche" || res="$w Wochen"
    if [ "$d" -gt 0 ]; then
      res+=", "
      [ "$d" -eq 1 ] && res+="1 Tag" || res+="$d Tage"
    fi
  else
    if [ "$d" -gt 0 ]; then
      [ "$d" -eq 1 ] && res="1 Tag" || res="$d Tage"
    fi
    if [ "$h" -gt 0 ]; then
      [ -n "$res" ] && res+=", "
      [ "$h" -eq 1 ] && res+="1 Stunde" || res+="$h Stunden"
    fi
    if [ "$m" -gt 0 ] || [ -z "$res" ]; then
      [ -n "$res" ] && res+=", "
      [ "$m" -eq 1 ] && res+="1 Minute" || res+="$m Minuten"
    fi
  fi
  echo "$res"
}

# ---- Hardware-IP-Ermittlung ----
get_hw_ipv4s() {
  local out="" iface ipline ip
  for iface in $(ls -1 /sys/class/net 2>/dev/null); do
    [ "$iface" = "lo" ] && continue
    [ -e "/sys/class/net/$iface/device" ] || continue
    ip link show dev "$iface" 2>/dev/null | grep -q "UP" || continue
    while IFS= read -r ipline; do
      ip=$(echo "$ipline" | awk '{print $4}' | cut -d/ -f1)
      [ -n "$ip" ] && out+="${iface}: ${ip}, "
    done < <(ip -o -4 addr show dev "$iface" scope global 2>/dev/null)
  done
  if [ -z "$out" ]; then
    for iface in $(ls -1 /sys/class/net 2>/dev/null); do
      [ "$iface" = "lo" ] && continue
      [ -e "/sys/class/net/$iface/device" ] || continue
      while IFS= read -r ipline; do
        ip=$(echo "$ipline" | awk '{print $4}' | cut -d/ -f1)
        [ -n "$ip" ] && out+="${iface}: ${ip}, "
      done < <(ip -o -4 addr show dev "$iface" scope global 2>/dev/null)
    done
  fi
  [ -z "$out" ] && echo "N/A" || echo "${out%, }"
}

<<<<<<< HEAD
# ---- Remote-IP/Host ermitteln ----
=======
# ---- Remote-IP/Host ----
>>>>>>> d650781fdc0dfe702770c03052eefb935f3d50b7
get_remote_host() {
  local rh=""
  if [ -n "$SSH_CLIENT" ]; then
    rh=${SSH_CLIENT%% *}
  elif [ -n "$SSH_CONNECTION" ]; then
    rh=${SSH_CONNECTION%% *}
  fi
  if [ -z "$rh" ] && command -v who >/dev/null 2>&1; then
    local ttydev
    ttydev=$(tty 2>/dev/null)
    [ -z "$ttydev" ] && ttydev=$(ps -o tty= -p $$ 2>/dev/null)
    ttydev=${ttydev#/dev/}
    if who --help 2>&1 | grep -q -- "--ips"; then
      rh=$(who --ips 2>/dev/null | awk -v t="$ttydev" '
        $2==t {
          for (i=NF; i>=1; i--) {
            gsub(/[()]/,"",$i)
            if ($i ~ /^([0-9]{1,3}\.){3}[0-9]{1,3}$/ || $i ~ /^[0-9a-fA-F:]+$/) { print $i; exit }
          }
        }')
    fi
  fi
  if [ -z "$rh" ] && command -v who >/dev/null 2>&1; then
    rh=$(who -m 2>/dev/null | awk -F'[()]' '{print $(NF-1)}' | awk 'NF')
  fi
  if [ -z "$rh" ] && command -v ss >/dev/null 2>&1; then
    local pid=$$ ppid comm sshdpid="" line peer=""
    while [ -n "$pid" ] && [ "$pid" -ne 1 ] && [ -r "/proc/$pid/status" ]; do
      ppid=$(awk '/^PPid:/ {print $2}' /proc/$pid/status 2>/dev/null)
      comm=$(cat /proc/$pid/comm 2>/dev/null)
      if [ "$comm" = "sshd" ]; then sshdpid="$pid"; break; fi
      pid="$ppid"
    done
    if [ -n "$sshdpid" ]; then
      line=$(ss -Htnp state established 2>/dev/null | awk -v pid="$sshdpid" '$0 ~ ("pid=" pid) {print; exit}')
      if [ -n "$line" ]; then
        peer=$(echo "$line" | awk '{
          u=0; for (i=1;i<=NF;i++) if ($i ~ /^users:/) {u=i; break}
          if (u>1) print $(u-1);
        }')
        peer=$(echo "$peer" | sed -E 's/^\[?([0-9a-fA-F:]+)\]?(:[0-9]+)?$/\1/')
        [ -n "$peer" ] && rh="$peer"
      fi
    fi
  fi
  [ -n "$rh" ] && echo "$rh" || echo "N/A"
}

# ---- Daten sammeln ----
datum=$(date +"%d.%m.%Y %H:%M:%S")
cpus=$(nproc)
load_raw=$(awk '{print $1}' /proc/loadavg)
load_pct=$(awk -v l="$load_raw" -v c="$cpus" 'BEGIN {printf "%.1f%%", (l/c)*100}')
free_root_pct=$(df -P / | awk 'NR==2 {printf "%.0f%%", ($4/$2)*100}')
memory_usage=$(free -m | awk 'NR==2{printf "%.2f%%", $3*100/$2 }')
swap_usage=$(free -m | awk '/^Swap/ { if ($2==0) print "0.0%"; else printf "%.1f%%", $3*100/$2 }')
processes=$(ps ax | wc -l)
ips_hw=$(get_hw_ipv4s)
current_user=$(whoami)
remote_host=$(get_remote_host)
uptime_secs=$(awk '{print int($1)}' /proc/uptime)
uptime_de=$(de_uptime "$uptime_secs")

to_de() { echo "$1" | sed 's/\./,/' ; }
load_pct_de=$(to_de "$load_pct")
memory_usage_de=$(to_de "$memory_usage")
swap_usage_de=$(to_de "$swap_usage")

# ---- Tabelle ----
rows=(
  "IP-Adresse(n):|$ips_hw|Systemlaufzeit:|$uptime_de"
  "Systemlast:|$load_pct_de|Prozesse:|$processes"
  "RAM benutzt:|$memory_usage_de|Swap benutzt:|$swap_usage_de"
  "Freier Speicherplatz:|$free_root_pct||"
  "||Aktueller Nutzer:|$current_user"
  "||Remote Host:|$remote_host"
)

maxL1=0; maxL2=0; maxR1=0; maxR2=0
for row in "${rows[@]}"; do
  IFS="|" read -r l1 v1 l2 v2 <<<"$row"
  (( ${#l1} > maxL1 )) && maxL1=${#l1}
  (( ${#v1} > maxL2 )) && maxL2=${#v1}
  (( ${#l2} > maxR1 )) && maxR1=${#l2}
  (( ${#v2} > maxR2 )) && maxR2=${#v2}
done
minL1=14; minV1=14; minL2=16; minV2=14
(( maxL1 < minL1 )) && maxL1=$minL1
(( maxL2 < minV1 )) && maxL2=$minV1
(( maxR1 < minL2 )) && maxR1=$minL2
(( maxR2 < minV2 )) && maxR2=$minV2
gapstr=$(printf "%*s" "$GAP" "")
table_width=$(( maxL1 + GAP + maxL2 + GAP + maxR1 + GAP + maxR2 ))
header="Systeminformationen am $datum"
pad=0; [ $table_width -gt ${#header} ] && pad=$(( (table_width - ${#header}) / 2 ))

printf "${COLOR}%*s%s${RESET}\n\n" "$pad" "" "$header"

for row in "${rows[@]}"; do
  IFS="|" read -r l1 v1 l2 v2 <<<"$row"
  if [[ "$l2" == "Aktueller Nutzer:" || "$l2" == "Remote Host:" ]]; then
    printf "${COLOR}%-*s%s%-*s%s%-*s%s${RESET}" \
      "$maxL1" "$l1" "$gapstr" \
      "$maxL2" "$v1" "$gapstr" \
      "$maxR1" "$l2" "$gapstr"
    padded_v2=$(printf "%-*s" "$maxR2" "$v2")
    if [ -x "$LOLCAT_BIN" ] && [ "$v2" != "N/A" ]; then
      printf "%s" "$padded_v2" | "$LOLCAT_BIN" $LOLCAT_ARGS
      printf "${RESET}\n"
    else
      printf "${COLOR}%s${RESET}\n" "$padded_v2"
    fi
  else
    printf "${COLOR}%-*s%s%-*s%s%-*s%s%-*s${RESET}\n" \
      "$maxL1" "$l1" "$gapstr" \
      "$maxL2" "$v1" "$gapstr" \
      "$maxR1" "$l2" "$gapstr" \
      "$maxR2" "$v2"
  fi
done

echo

# ---- Paket-Updates (tabellarisch ausgerichtet) ----
if command -v apt-get >/dev/null 2>&1; then
  apt-get update -qq >/dev/null 2>&1
  CODENAME=$(. /etc/os-release 2>/dev/null; echo "${VERSION_CODENAME:-$UBUNTU_CODENAME}")

  # ggf. von au√üen gesetzter Modus (upgrade/dist-upgrade)
  if [ "${UPGRADE_MODE:-upgrade}" = "dist-upgrade" ]; then
    sim_out=$(LC_ALL=C apt-get -s dist-upgrade 2>/dev/null)
  else
    sim_out=$(LC_ALL=C apt-get -s upgrade 2>/dev/null)
  fi

  # Paketliste aus der Simulation
  mapfile -t pkgs < <(printf "%s\n" "$sim_out" | awk '/^Inst /{print $2}')
  updates=${#pkgs[@]}

  if [ "$updates" -gt 0 ]; then
    rows_sec=()   # Elemente: pkg<TAB>info<TAB>tag
    rows_norm=()
    max_pkg=0; max_info=0; max_tag=0

    for pkg in "${pkgs[@]}"; do
      policy=$(LC_ALL=C apt-cache policy "$pkg" 2>/dev/null)
      old=$(printf "%s\n" "$policy" | awk '/Installed:/{print $2}')
      new=$(printf "%s\n" "$policy" | awk '/Candidate:/{print $2}')
      [ -z "$old" ] || [ "$old" = "(none)" ] && old="n/a"
      [ -z "$new" ] && new="n/a"

      info_col="(alt: ${old} ‚Üí neu: ${new})"

      # Security-/ESM-Erkennung
      if printf "%s\n" "$policy" | grep -qiE "(^|[[:space:]/])${CODENAME}-security([/[:space:]]|$)|(^|[[:space:]])esm([/[:space:]]|$)"; then
        tag_col="üîí Sicherheitsupdate"
        rows_sec+=("$pkg"$'\t'"$info_col"$'\t'"$tag_col")
      else
        tag_col="Update"
        rows_norm+=("$pkg"$'\t'"$info_col"$'\t'"$tag_col")
      fi

      # Maxbreiten bestimmen (√ºber alle Zeilen/Bl√∂cke)
      (( ${#pkg}      > max_pkg  )) && max_pkg=${#pkg}
      (( ${#info_col} > max_info )) && max_info=${#info_col}
      (( ${#tag_col}  > max_tag  )) && max_tag=${#tag_col}
    done

    sec_count=${#rows_sec[@]}
    printf "${COLOR}üì¶ Es sind %s Paket-Updates verf√ºgbar, davon %s Sicherheitsupdates:${RESET}\n" "$updates" "$sec_count"

    # Separator zwischen Spalten (wenn du gar keine sichtbaren Trenner willst, setze SEP="" oder "  ")
    SEP="  "

    # Sicherheitsupdates
    if [ "$sec_count" -gt 0 ]; then
      printf "\n${COLOR}üîê Sicherheitsupdates:${RESET}\n"
      for row in "${rows_sec[@]}"; do
        IFS=$'\t' read -r pkg info_col tag_col <<<"$row"
        # ‚Äûtabellarisch‚Äú, aber ohne sichtbare Tabelle: Spalten exakt gepolstert
        printf "  - %-*s%s%-*s%s%-*s\n" \
          "$max_pkg"  "$pkg" \
          "$SEP" \
          "$max_info" "$info_col" \
          "$SEP" \
          "$max_tag"  "$tag_col"
      done
    fi

    # Weitere Updates
    if [ "${#rows_norm[@]}" -gt 0 ]; then
      printf "\n${COLOR}üß∞ Weitere Updates:${RESET}\n"
      for row in "${rows_norm[@]}"; do
        IFS=$'\t' read -r pkg info_col tag_col <<<"$row"
        printf "  - %-*s%s%-*s%s%-*s\n" \
          "$max_pkg"  "$pkg" \
          "$SEP" \
          "$max_info" "$info_col" \
          "$SEP" \
          "$max_tag"  "$tag_col"
      done
    fi
  else
    printf "${COLOR}üì¶ Alle Pakete sind aktuell.${RESET}\n"
  fi
fi
