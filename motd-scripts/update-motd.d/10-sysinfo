#!/bin/bash
#
# - Nur IPs physischer NICs (keine Docker/veth/lo)
# - Remote-IP ermitteln
# - Ab 1 Woche: Uptime ohne Stunden/Minuten

# ---- Optik ----
COLOR="\033[38;5;114m"
RESET="\033[0m"
GAP=3
LOLCAT_BIN="/usr/local/bin/lolcat"
LOLCAT_ARGS="-f -p 1.2 -F 0.3"

# Zusatzfarben f√ºr Container-Zusammenfassung (au√üerhalb der Tabelle)
GREEN="\033[1;32m"
YELLOW="\033[1;33m"

# ---- Optionen ----
UPGRADE_MODE="upgrade"
if [ "${1:-}" = "--dist" ]; then
  UPGRADE_MODE="dist-upgrade"
fi

# Zeige farbige Container-Zusammenfassung unter der Tabelle (1=ja, 0=nein)
SHOW_CONTAINER_SUMMARY=1

# ---- Helfer: deutsche Uptime ----
de_uptime() {
  local s="$1" w d h m res=""
  w=$(( s/604800 )); s=$(( s%604800 ))
  d=$(( s/86400  )); s=$(( s%86400  ))
  h=$(( s/3600   )); s=$(( s%3600   ))
  m=$(( s/60     ))

  if [ "$w" -gt 0 ]; then
    [ "$w" -eq 1 ] && res="1 Woche" || res="$w Wochen"
    if [ "$d" -gt 0 ]; then
      res+=", "
      [ "$d" -eq 1 ] && res+="1 Tag" || res+="$d Tage"
    fi
  else
    if [ "$d" -gt 0 ]; then
      [ "$d" -eq 1 ] && res="1 Tag" || res="$d Tage"
    fi
    if [ "$h" -gt 0 ]; then
      [ -n "$res" ] && res+=", "
      [ "$h" -eq 1 ] && res+="1 Stunde" || res+="$h Stunden"
    fi
    if [ "$m" -gt 0 ] || [ -z "$res" ]; then
      [ -n "$res" ] && res+=", "
      [ "$m" -eq 1 ] && res+="1 Minute" || res+="$m Minuten"
    fi
  fi
  echo "$res"
}

# ---- Hardware-IP-Ermittlung ----
get_hw_ipv4s() {
  local out="" iface ipline ip
  for iface in $(ls -1 /sys/class/net 2>/dev/null); do
    [ "$iface" = "lo" ] && continue
    [ -e "/sys/class/net/$iface/device" ] || continue
    ip link show dev "$iface" 2>/dev/null | grep -q "UP" || continue
    while IFS= read -r ipline; do
      ip=$(echo "$ipline" | awk '{print $4}' | cut -d/ -f1)
      [ -n "$ip" ] && out+="${iface}: ${ip}, "
    done < <(ip -o -4 addr show dev "$iface" scope global 2>/dev/null)
  done
  if [ -z "$out" ]; then
    for iface in $(ls -1 /sys/class/net 2>/dev/null); do
      [ "$iface" = "lo" ] && continue
      [ -e "/sys/class/net/$iface/device" ] || continue
      while IFS= read -r ipline; do
        ip=$(echo "$ipline" | awk '{print $4}' | cut -d/ -f1)
        [ -n "$ip" ] && out+="${iface}: ${ip}, "
      done < <(ip -o -4 addr show dev "$iface" scope global 2>/dev/null)
    done
  fi
  [ -z "$out" ] && echo "N/A" || echo "${out%, }"
}

# ---- Remote-IP/Host ----
get_remote_host() {
  local rh=""

  # 1) SSH_CONNECTION (stabil bei SSH-Sessions)
  if [ -n "$SSH_CONNECTION" ]; then
    rh=${SSH_CONNECTION%% *}
  elif [ -n "$SSH_CLIENT" ]; then
    rh=${SSH_CLIENT%% *}
  fi

  # 2) systemd-logind (falls vorhanden)
  if [ -z "$rh" ] && command -v loginctl >/dev/null 2>&1; then
    local sid
    sid=$(loginctl show-session "$XDG_SESSION_ID" -p RemoteHost 2>/dev/null | cut -d= -f2)
    [ -n "$sid" ] && rh="$sid"
  fi

  # 3) ss: Parent-sshd ermitteln und Peer-Adresse auslesen
  if [ -z "$rh" ] && command -v ss >/dev/null 2>&1; then
    local pid=$$
    local sshdpid=""
    while [ "$pid" -gt 1 ] && [ -r "/proc/$pid/status" ]; do
      local comm
      comm=$(cat /proc/$pid/comm 2>/dev/null)
      if [ "$comm" = "sshd" ]; then
        sshdpid="$pid"
        break
      fi
      pid=$(awk '/^PPid:/ {print $2}' /proc/$pid/status)
    done

    if [ -n "$sshdpid" ]; then
      local peer
      peer=$(ss -Htnp state established 2>/dev/null \
        | grep "pid=$sshdpid" \
        | sed -E 's/.* ([0-9.:a-fA-F]+):[0-9]+ +users:.*/\1/' \
        | head -n1)
      [ -n "$peer" ] && rh="$peer"
    fi
  fi

  [ -n "$rh" ] && echo "$rh" || echo "N/A"
}

# ---- Container-Helfer ----
_join_first_n_names() {
  # liest Namen aus stdin, gibt "a, b, c +X weitere" zur√ºck (max 3 Namen)
  local max=3 names=() n extra
  while IFS= read -r n; do
    [ -n "$n" ] && names+=("$n")
  done
  local count=${#names[@]}
  if [ "$count" -eq 0 ]; then
    echo "-"
    return 0
  fi
  local limit=$(( count<max ? count : max ))
  local out=""
  for ((i=0; i<limit; i++)); do
    if [ $i -gt 0 ]; then out+=", "; fi
    out+="${names[$i]}"
  done
  extra=$(( count - limit ))
  if [ "$extra" -gt 0 ]; then
    out+=" +${extra} weitere"
  fi
  echo "$out"
}

get_container_overview() {
  # Gibt 4 *Zeilen* aus:
  # 1: running_count
  # 2: running_names (kompakt, inkl. Spaces)
  # 3: stopped_count
  # 4: stopped_names
  if ! command -v docker >/dev/null 2>&1; then
    echo "0"
    echo "-"
    echo "0"
    echo "-"
    return 0
  fi

  # Aktive Container
  local running_count running_names
  running_count=$(docker ps -q 2>/dev/null | wc -l | tr -d ' ')
  running_names=$(docker ps --format '{{.Names}}' 2>/dev/null | _join_first_n_names)

  # Gestoppte Container (status=exited)
  local stopped_count stopped_names
  stopped_count=$(docker ps -aq -f status=exited 2>/dev/null | wc -l | tr -d ' ')
  stopped_names=$(docker ps -a -f status=exited --format '{{.Names}}' 2>/dev/null | _join_first_n_names)

  echo "$running_count"
  echo "$running_names"
  echo "$stopped_count"
  echo "$stopped_names"
}

# ---- Daten sammeln ----
datum=$(date +"%d.%m.%Y %H:%M:%S")
cpus=$(nproc)
load_raw=$(awk '{print $1}' /proc/loadavg)
load_pct=$(awk -v l="$load_raw" -v c="$cpus" 'BEGIN {printf "%.1f%%", (l/c)*100}')
free_root_pct=$(df -P / | awk 'NR==2 {printf "%.0f%%", ($4/$2)*100}')
memory_usage=$(free -m | awk 'NR==2{printf "%.2f%%", $3*100/$2 }')
swap_usage=$(free -m | awk '/^Swap/ { if ($2==0) print "0.0%"; else printf "%.1f%%", $3*100/$2 }')
processes=$(ps ax | wc -l)
ips_hw=$(get_hw_ipv4s)
current_user=$(whoami)
remote_host=$(get_remote_host)
uptime_secs=$(awk '{print int($1)}' /proc/uptime)
uptime_de=$(de_uptime "$uptime_secs")

# Container-Daten robust holen (mapfile beh√§lt Zeilen inkl. Leerzeichen)
cont_running_count="0"
cont_running_names="-"
cont_stopped_count="0"
cont_stopped_names="-"
if command -v docker >/dev/null 2>&1; then
  mapfile -t _dock < <( get_container_overview )
  cont_running_count="${_dock[0]:-0}"
  cont_running_names="${_dock[1]:--}"
  cont_stopped_count="${_dock[2]:-0}"
  cont_stopped_names="${_dock[3]:--}"
fi

to_de() { echo "$1" | sed 's/\./,/' ; }
load_pct_de=$(to_de "$load_pct")
memory_usage_de=$(to_de "$memory_usage")
swap_usage_de=$(to_de "$swap_usage")

# ---- Tabelle ----
rows=(
  "IP-Adresse(n):|$ips_hw|Systemlaufzeit:|$uptime_de"
  "Systemlast:|$load_pct_de|Prozesse:|$processes"
  "RAM benutzt:|$memory_usage_de|Swap benutzt:|$swap_usage_de"
  "Freier Speicherplatz:|$free_root_pct||"
  "||Aktueller Nutzer:|$current_user"
  "||Remote Host:|$remote_host"
)

maxL1=0; maxL2=0; maxR1=0; maxR2=0
for row in "${rows[@]}"; do
  IFS="|" read -r l1 v1 l2 v2 <<<"$row"
  (( ${#l1} > maxL1 )) && maxL1=${#l1}
  (( ${#v1} > maxL2 )) && maxL2=${#v1}
  (( ${#l2} > maxR1 )) && maxR1=${#l2}
  (( ${#v2} > maxR2 )) && maxR2=${#v2}
done
minL1=14; minV1=14; minL2=16; minV2=14
(( maxL1 < minL1 )) && maxL1=$minL1
(( maxL2 < minV1 )) && maxL2=$minV1
(( maxR1 < minL2 )) && maxR1=$minL2
(( maxR2 < minV2 )) && maxR2=$minV2
gapstr=$(printf "%*s" "$GAP" "")
table_width=$(( maxL1 + GAP + maxL2 + GAP + maxR1 + GAP + maxR2 ))
header="Systeminformationen am $datum"
pad=0; [ $table_width -gt ${#header} ] && pad=$(( (table_width - ${#header}) / 2 ))

printf "${COLOR}%*s%s${RESET}\n\n" "$pad" "" "$header"

for row in "${rows[@]}"; do
  IFS="|" read -r l1 v1 l2 v2 <<<"$row"
  if [[ "$l2" == "Aktueller Nutzer:" || "$l2" == "Remote Host:" ]]; then
    printf "${COLOR}%-*s%s%-*s%s%-*s%s${RESET}" \
      "$maxL1" "$l1" "$gapstr" \
      "$maxL2" "$v1" "$gapstr" \
      "$maxR1" "$l2" "$gapstr"
    padded_v2=$(printf "%-*s" "$maxR2" "$v2")
    if [ -x "$LOLCAT_BIN" ] && [ "$v2" != "N/A" ]; then
      printf "%s" "$padded_v2" | "$LOLCAT_BIN" $LOLCAT_ARGS
      printf "${RESET}\n"
    else
      printf "${COLOR}%s${RESET}\n" "$padded_v2"
    fi
  else
    printf "${COLOR}%-*s%s%-*s%s%-*s%s%-*s${RESET}\n" \
      "$maxL1" "$l1" "$gapstr" \
      "$maxL2" "$v1" "$gapstr" \
      "$maxR1" "$l2" "$gapstr" \
      "$maxR2" "$v2"
  fi
done

echo

# ---- Farbliche Kurz-Zusammenfassung (ohne Tabellenauswirkung) ----
if [ "$SHOW_CONTAINER_SUMMARY" = "1" ] && command -v docker >/dev/null 2>&1; then
  # Kopfzeile
  printf "%büê≥ Docker-Container%b\n" "$COLOR" "$RESET"
  # zwei sch√∂n ausgerichtete Zeilen
  printf "   %bAktiv%b     : %b%-3s%b (%s)\n"    "$COLOR" "$RESET" "$GREEN"  "$cont_running_count" "$RESET" "$cont_running_names"
  printf "   %bGestoppt%b  : %b%-3s%b (%s)\n\n"  "$COLOR" "$RESET" "$YELLOW" "$cont_stopped_count" "$RESET" "$cont_stopped_names"
fi

# ---- Paket-Updates (tabellarisch ausgerichtet) ----
if command -v apt-get >/dev/null 2>&1; then
  apt-get update -qq >/dev/null 2>&1
  CODENAME=$(. /etc/os-release 2>/dev/null; echo "${VERSION_CODENAME:-$UBUNTU_CODENAME}")

  # ggf. von au√üen gesetzter Modus (upgrade/dist-upgrade)
  if [ "${UPGRADE_MODE:-upgrade}" = "dist-upgrade" ]; then
    sim_out=$(LC_ALL=C apt-get -s dist-upgrade 2>/dev/null)
  else
    sim_out=$(LC_ALL=C apt-get -s upgrade 2>/dev/null)
  fi

  # Paketliste aus der Simulation
  mapfile -t pkgs < <(printf "%s\n" "$sim_out" | awk '/^Inst /{print $2}')
  updates=${#pkgs[@]}

  if [ "$updates" -gt 0 ]; then
    rows_sec=()   # Elemente: pkg<TAB>info<TAB>tag
    rows_norm=()
    max_pkg=0; max_info=0; max_tag=0

    for pkg in "${pkgs[@]}"; do
      policy=$(LC_ALL=C apt-cache policy "$pkg" 2>/dev/null)
      old=$(printf "%s\n" "$policy" | awk '/Installed:/{print $2}')
      new=$(printf "%s\n" "$policy" | awk '/Candidate:/{print $2}')
      [ -z "$old" ] || [ "$old" = "(none)" ] && old="n/a"
      [ -z "$new" ] && new="n/a"

      info_col="(alt: ${old} ‚Üí neu: ${new})"

      # Security-/ESM-Erkennung
      if printf "%s\n" "$policy" | grep -qiE "(^|[[:space:]/])${CODENAME}-security([/[:space:]]|$)|(^|[[:space:]])esm([/[:space:]]|$)"; then
        tag_col="üîí Sicherheitsupdate"
        rows_sec+=("$pkg"$'\t'"$info_col"$'\t'"$tag_col")
      else
        tag_col="Update"
        rows_norm+=("$pkg"$'\t'"$info_col"$'\t'"$tag_col")
      fi

      # Maxbreiten bestimmen (√ºber alle Zeilen/Bl√∂cke)
      (( ${#pkg}      > max_pkg  )) && max_pkg=${#pkg}
      (( ${#info_col} > max_info )) && max_info=${#info_col}
      (( ${#tag_col}  > max_tag  )) && max_tag=${#tag_col}
    done

    sec_count=${#rows_sec[@]}
    printf "${COLOR}üì¶ Es sind %s Paket-Updates verf√ºgbar, davon %s Sicherheitsupdates:${RESET}\n" "$updates" "$sec_count"

    # Separator zwischen Spalten (wenn du gar keine sichtbaren Trenner willst, setze SEP="" oder "  ")
    SEP="  "

    # Sicherheitsupdates
    if [ "$sec_count" -gt 0 ]; then
      printf "\n${COLOR}üîê Sicherheitsupdates:${RESET}\n"
      for row in "${rows_sec[@]}"; do
        IFS=$'\t' read -r pkg info_col tag_col <<<"$row"
        # ‚Äûtabellarisch‚Äú, aber ohne sichtbare Tabelle: Spalten exakt gepolstert
        printf "  - %-*s%s%-*s%s%-*s\n" \
          "$max_pkg"  "$pkg" \
          "$SEP" \
          "$max_info" "$info_col" \
          "$SEP" \
          "$max_tag"  "$tag_col"
      done
    fi

    # Weitere Updates
    if [ "${#rows_norm[@]}" -gt 0 ]; then
      printf "\n${COLOR}üß∞ Weitere Updates:${RESET}\n"
      for row in "${rows_norm[@]}"; do
        IFS=$'\t' read -r pkg info_col tag_col <<<"$row"
        printf "  - %-*s%s%-*s%s%-*s\n" \
          "$max_pkg"  "$pkg" \
          "$SEP" \
          "$max_info" "$info_col" \
          "$SEP" \
          "$max_tag"  "$tag_col"
      done
    fi
  else
    printf "${COLOR}üì¶ Alle Pakete sind aktuell.${RESET}\n"
  fi
fi
